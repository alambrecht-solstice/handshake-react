{"ast":null,"code":"import _slicedToArray from \"/Users/alexlambrecht/koko/handshake-test/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2019 Victor Dibia.\n * Handtrack.js - A library for prototyping realtime hand tracking using neural networks.\n * Licensed under the MIT License (the \"License\"); \n * Code snippets from the tensorflow coco-ssd example are reused here - https://github.com/tensorflow/tfjs-models/tree/master/coco-ssd\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs';\nconst basePath = \"https://cdn.jsdelivr.net/npm/handtrackjs/models/web/\";\nconst defaultParams = {\n  flipHorizontal: true,\n  outputStride: 16,\n  imageScaleFactor: 0.7,\n  maxNumBoxes: 20,\n  iouThreshold: 0.5,\n  scoreThreshold: 0.99,\n  modelType: \"ssdlitemobilenetv2\"\n};\nexport async function load(params) {\n  let modelParams = Object.assign({}, defaultParams, params); // console.log(modelParams) \n\n  const objectDetection = new ObjectDetection(modelParams);\n  await objectDetection.load();\n  return objectDetection;\n}\nexport function startVideo(video) {\n  // Video must have height and width in order to be used as input for NN\n  // Aspect ratio of 3/4 is used to support safari browser.\n  video.width = video.width || 640;\n  video.height = video.height || video.width * (3 / 4);\n  return new Promise(function (resolve, reject) {\n    navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: {\n        facingMode: \"user\"\n      }\n    }).then(stream => {\n      window.localStream = stream;\n      video.srcObject = stream;\n\n      video.onloadedmetadata = () => {\n        video.play();\n        resolve(true);\n      };\n    }).catch(function (err) {\n      resolve(false);\n    });\n  });\n}\nexport async function stopVideo() {\n  if (window.localStream) {\n    window.localStream.getTracks().forEach(track => {\n      track.stop();\n      return true;\n    });\n  } else {\n    return false;\n  }\n}\nexport class ObjectDetection {\n  constructor(modelParams) {\n    this.modelPath = basePath + modelParams.modelType + \"/tensorflowjs_model.pb\";\n    this.weightPath = basePath + modelParams.modelType + \"/weights_manifest.json\";\n    this.modelParams = modelParams;\n  }\n\n  async load() {\n    this.fps = 0;\n    this.model = await tf.loadFrozenModel(this.modelPath, this.weightPath); // Warmup the model.\n\n    const result = await this.model.executeAsync(tf.zeros([1, 300, 300, 3]));\n    result.map(async t => await t.data());\n    result.map(async t => t.dispose()); // console.log(\"model loaded and warmed up\")\n  }\n\n  async detect(input) {\n    let timeBegin = Date.now();\n\n    const _getInputTensorDimens = getInputTensorDimensions(input),\n          _getInputTensorDimens2 = _slicedToArray(_getInputTensorDimens, 2),\n          height = _getInputTensorDimens2[0],\n          width = _getInputTensorDimens2[1];\n\n    const resizedHeight = getValidResolution(this.modelParams.imageScaleFactor, height, this.modelParams.outputStride);\n    const resizedWidth = getValidResolution(this.modelParams.imageScaleFactor, width, this.modelParams.outputStride);\n    const batched = tf.tidy(() => {\n      const imageTensor = tf.fromPixels(input);\n\n      if (this.modelParams.flipHorizontal) {\n        return imageTensor.reverse(1).resizeBilinear([resizedHeight, resizedWidth]).expandDims(0);\n      } else {\n        return imageTensor.resizeBilinear([resizedHeight, resizedWidth]).expandDims(0);\n      }\n    }); // const result = await this.model.executeAsync(batched);\n\n    self = this;\n    return this.model.executeAsync(batched).then(function (result) {\n      const scores = result[0].dataSync();\n      const boxes = result[1].dataSync(); // clean the webgl tensors\n\n      batched.dispose();\n      tf.dispose(result); // console.log(\"scores result\",scores, boxes)\n\n      const _calculateMaxScores = calculateMaxScores(scores, result[0].shape[1], result[0].shape[2]),\n            _calculateMaxScores2 = _slicedToArray(_calculateMaxScores, 2),\n            maxScores = _calculateMaxScores2[0],\n            classes = _calculateMaxScores2[1];\n\n      const prevBackend = tf.getBackend(); // run post process in cpu\n\n      tf.setBackend('cpu');\n      const indexTensor = tf.tidy(() => {\n        const boxes2 = tf.tensor2d(boxes, [result[1].shape[1], result[1].shape[3]]);\n        return tf.image.nonMaxSuppression(boxes2, scores, self.modelParams.maxNumBoxes, // maxNumBoxes\n        self.modelParams.iouThreshold, // iou_threshold\n        self.modelParams.scoreThreshold // score_threshold\n        );\n      });\n      const indexes = indexTensor.dataSync();\n      indexTensor.dispose(); // restore previous backend\n\n      tf.setBackend(prevBackend);\n      const predictions = self.buildDetectedObjects(width, height, boxes, scores, indexes, classes);\n      let timeEnd = Date.now();\n      self.fps = Math.round(1000 / (timeEnd - timeBegin));\n      return predictions;\n    });\n  }\n\n  buildDetectedObjects(width, height, boxes, scores, indexes, classes) {\n    const count = indexes.length;\n    const objects = [];\n\n    for (let i = 0; i < count; i++) {\n      const bbox = [];\n\n      for (let j = 0; j < 4; j++) {\n        bbox[j] = boxes[indexes[i] * 4 + j];\n      }\n\n      const minY = bbox[0] * height;\n      const minX = bbox[1] * width;\n      const maxY = bbox[2] * height;\n      const maxX = bbox[3] * width;\n      bbox[0] = minX;\n      bbox[1] = minY;\n      bbox[2] = maxX - minX;\n      bbox[3] = maxY - minY;\n      objects.push({\n        bbox: bbox,\n        class: classes[indexes[i]],\n        score: scores[indexes[i]]\n      });\n    }\n\n    return objects;\n  }\n\n  getFPS() {\n    return this.fps;\n  }\n\n  setModelParameters(params) {\n    this.modelParams = Object.assign({}, this.modelParams, params);\n  }\n\n  getModelParameters() {\n    return this.modelParams;\n  }\n\n  renderPredictions(predictions, canvas, context, mediasource) {\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    canvas.width = mediasource.width;\n    canvas.height = mediasource.height; // console.log(\"render\", mediasource.width, mediasource.height)\n\n    context.save();\n\n    if (this.modelParams.flipHorizontal) {\n      context.scale(-1, 1);\n      context.translate(-mediasource.width, 0);\n    }\n\n    context.drawImage(mediasource, 0, 0, mediasource.width, mediasource.height);\n    context.restore();\n    context.font = '10px Arial'; // console.log('number of detections: ', predictions.length);\n\n    for (let i = 0; i < predictions.length; i++) {\n      context.beginPath();\n      context.fillStyle = \"rgba(255, 255, 255, 0.6)\";\n      context.fillRect(predictions[i].bbox[0], predictions[i].bbox[1] - 17, predictions[i].bbox[2], 17);\n      context.rect(...predictions[i].bbox); // draw a dot at the center of bounding box\n\n      context.lineWidth = 1;\n      context.strokeStyle = '#0063FF';\n      context.fillStyle = \"#0063FF\"; // \"rgba(244,247,251,1)\";\n\n      context.fillRect(predictions[i].bbox[0] + predictions[i].bbox[2] / 2, predictions[i].bbox[1] + predictions[i].bbox[3] / 2, 5, 5);\n      context.stroke();\n      context.fillText(predictions[i].score.toFixed(3) + ' ' + \" | hand\", predictions[i].bbox[0] + 5, predictions[i].bbox[1] > 10 ? predictions[i].bbox[1] - 5 : 10);\n    } // Write FPS to top left\n\n\n    context.font = \"bold 12px Arial\";\n    context.fillText(\"[FPS]: \" + this.fps, 10, 20);\n  }\n\n  dispose() {\n    if (this.model) {\n      this.model.dispose();\n    }\n  }\n\n}\n\nfunction getValidResolution(imageScaleFactor, inputDimension, outputStride) {\n  const evenResolution = inputDimension * imageScaleFactor - 1;\n  return evenResolution - evenResolution % outputStride + 1;\n}\n\nfunction getInputTensorDimensions(input) {\n  return input instanceof tf.Tensor ? [input.shape[0], input.shape[1]] : [input.height, input.width];\n}\n\nfunction calculateMaxScores(scores, numBoxes, numClasses) {\n  const maxes = [];\n  const classes = [];\n\n  for (let i = 0; i < numBoxes; i++) {\n    let max = Number.MIN_VALUE;\n    let index = -1;\n\n    for (let j = 0; j < numClasses; j++) {\n      if (scores[i * numClasses + j] > max) {\n        max = scores[i * numClasses + j];\n        index = j;\n      }\n    }\n\n    maxes[i] = max;\n    classes[i] = index;\n  } // console.log([maxes, classes])\n\n\n  return [maxes, classes];\n}","map":null,"metadata":{},"sourceType":"module"}